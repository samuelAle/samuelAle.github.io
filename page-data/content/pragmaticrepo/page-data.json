{"componentChunkName":"component---src-templates-post-js","path":"/content/pragmaticrepo/","result":{"data":{"markdownRemark":{"html":"<p>If you're working in a large company, there is a good chance that defining your own repository structure is out of your control.\nOr at least, any benefits it may provide would not outweigh the cost of diverging from long-standing company conventions.</p>\n<p>However, if you do have some control, allow me to share some advice.</p>\n<p>My goal in this article is to make clear, what the benefits are to structuring your repository in the following way.</p>\n<blockquote>\n<p>Note: I'm going to be using java + gradle as an example</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"default\"><pre class=\"language-default\"><code class=\"language-default\">.\nâ”œâ”€â”€ api.yml                          # Source of truth for the REST apis in this repository\nâ”œâ”€â”€ build.gradle                     # Defines build steps for compilation, tests, and publish\nâ”œâ”€â”€ infra                            # Contains definitions of infrastructure (such as k8s, aws, azure, monitors, etc)\nâ”œâ”€â”€ pipeline.yml                     # Defines the pipeline for this repository\nâ”œâ”€â”€ src\nâ”‚   â”œâ”€â”€ java                         # Source code\nâ”‚   â””â”€â”€ resources                    # Static resources\nâ”œâ”€â”€ test\nâ”‚   â”œâ”€â”€ unit                         # Unit tests for source code\nâ”‚   â””â”€â”€ integration                  # Integration tests for the service (should leverage the java-client)\nâ”œâ”€â”€ build/generated/src/java         # Generated source code for the service (rest controller, API models, etc)\nâ””â”€â”€ java-client\n    â”œâ”€â”€ build.gradle                 # Defines build steps for the java client\n    â””â”€â”€ build/generated/src/java     # Generated output from the specification.yml</code></pre></div>\n<h2>Benefits</h2>\n<h3>api.yml</h3>\n<p>This file is in reference to an <a href=\"https://swagger.io/specification\">OpenApi specification</a>.</p>\n<p>This should be one of the first files you create in a new repo.</p>\n<p>You can think of the specification.yml as a REST contract that defines what your service is going to expose.</p>\n<p>A number of artifacts can be generated from the API specification:</p>\n<ul>\n<li>A client SDK in <a href=\"https://github.com/OpenAPITools/openapi-generator/tree/master/docs/generators\">various languages</a></li>\n<li>Documentation in html or <a href=\"https://github.com/Mermade/widdershins/blob/master/README.md\">markdown</a></li>\n<li>\n<p>REST source code for the service</p>\n<ul>\n<li>For example, there is a Spring plugin that generates a RestController and inner RestMethods</li>\n</ul>\n</li>\n</ul>\n<h3>build.gradle</h3>\n<p>Specific to my java example, gradle is the build-system in use here.</p>\n<p>Dependencies are declared in this file</p>\n<blockquote>\n<p>check out the new <a href=\"https://docs.gradle.org/current/userguide/dependency_locking.html\">dependency locking feature</a></p>\n</blockquote>\n<h3>infra</h3>\n<p>This directory holds the definition files for the underlying infrastructure that this service needs</p>\n<p>For example, if you arre using terraform as the definition language to manage your AWS resources, you may have:</p>\n<div class=\"gatsby-highlight\" data-language=\"default\"><pre class=\"language-default\"><code class=\"language-default\">â”œâ”€â”€ environments\nâ”‚   â”œâ”€â”€ branch\nâ”‚   â”œâ”€â”€ dev\nâ”‚   â”œâ”€â”€ prod\nâ”‚   â””â”€â”€ stg\nâ”œâ”€â”€ modules\nâ”‚   â”œâ”€â”€ database\nâ”‚   â”œâ”€â”€ permissions\nâ”‚   â”œâ”€â”€ queue\nâ”‚   â””â”€â”€ monitors\nâ”œâ”€â”€ main.tf\nâ””â”€â”€ variables.tf</code></pre></div>\n<p>Some may argue that infrastructure should be defined in a separate repository, but you'd lose the following advantages:</p>\n<ul>\n<li>changes to infrastructure and the service get deployed together (one environment at a time)</li>\n<li>ability to rollback the infrastructure and the service at the same time</li>\n<li>code reviews improve when you see how changes in the infrastructure impact the service</li>\n<li>\n<p>temporary branch environments can be created to test features before merging to the master/main branch.</p>\n<ul>\n<li>This prevents resources conflicts in using shared infrastructure and allows multiple branch environments to remain isolated</li>\n</ul>\n</li>\n</ul>\n<h3>pipeline.yml</h3>\n<p>Many dev-ops platforms like <a href=\"https://docs.github.com/en/actions\">GitHub</a> and <a href=\"https://docs.gitlab.com/ee/ci/pipelines\">GitLab</a> both allow you to define your pipelines on a per-repo basis.</p>\n<p>This file defines how your service gets deployed through your environments, as well as how your service is deployed in a branch environment.</p>\n<p>this should also include how to deploy your infrastructure as well as publish any clients that are generated</p>\n<h3>src &#x26; test</h3>\n<ul>\n<li><strong>java</strong>: The actual source code for your repository</li>\n<li><strong>resources</strong>: The static resources for your repository</li>\n<li><strong>integration</strong>: Integration tests that are run in each environment</li>\n<li><strong>unit</strong>: Unit tests that cover 100% of lines in your repository ðŸ™ƒ</li>\n</ul>\n<h3>build/generated/src/java</h3>\n<p>Source code that is generated from the api.yml for the service</p>\n<p>Again, it is much better to rely on the <code class=\"language-text\">api.yml</code> file as the <em>source of truth</em>.\nIf you do this, then there will be no inconsistency between your generated clients and the service's HTTP layer.</p>\n<h3>java-client</h3>\n<p>A java client that is generated from the api.yml file.</p>\n<p>This java client <em>could</em> be defined in a separate repository, but a few reasons to keep it within your service repo is:</p>\n<ul>\n<li>The service's integration tests would more easily be able to consume the java client and test the service in the exact way your clients would be using it</li>\n<li>The pipeline can publish the client <strong>after</strong> the service completes deployment through production.</li>\n</ul>\n<h2>Cons</h2>\n<p>There aren't many cons that I've run into with this repository structure. Only one stands out to me at this time of writing:</p>\n<ul>\n<li>definition of the pipeline can become large and difficult to maintain</li>\n</ul>","frontmatter":{"title":"Pragmatic Repository Structure","date":"26 May, 2020","tags":["Infrastructure","Microservice","OpenApi"]}}},"pageContext":{"slug":"/content/pragmaticrepo/"}}}