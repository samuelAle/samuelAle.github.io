{"componentChunkName":"component---src-templates-post-js","path":"/content/httpclient/","result":{"data":{"markdownRemark":{"html":"<!--details>\n<summary>TL;DR</summary>\nhi, my name is sam\n</details>\n<br/>\n\nBefore jumping into my opinionated guide to client generation, I'd first like to take a moment to explain breifly, what an http client *is*.\nIn order to define this, let's break it down into two separate definitions (as silly as it may seem).\n\n<details>\n<summary>Expand for a basic summary of HTTP</summary>\n\n### What is HTTP\n\n[HTTP](https://www.w3schools.com/whatis/whatis_http.asp) is a protocol / procedure that web services follow to send and receive data from one another.\n\n```mermaid\ngraph LR\n    A(Client: Your Browser on google.com) -- Http Request --> B(Service: Google's Datacenter)\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">B -- Http Response --&gt; A</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">In the broader software industry, services typically communicate with each other via HTTP.\n(alternatives being RCP, AMQP, WebSockets, etc)\n\nWhile HTTP does well to explain where services should request &amp; send the data, it does not do a good job of explaining exactly how Company X formats their data.\nFor this reason, software developers invented additional specifications on top of HTTP to help describe the data being sent / received.\n\nThe most common/popular architectural style of using HTTP is called REST (REpresentational State Transfer).\n\nRESTful services leverage HTTP and build upon it to `receive` / process data effeciently.\nThere are many conventions and best practices to follow in order to build a well behaved RESTful service.\n\nIt can be daunting to started and follow best practices, but luckily there are many free frameworks that are available to help you get started. One of which is OpenApi.\n\n&lt;/details&gt;\n&lt;br/&gt;\n\n### Expectations of a modern http client\n\nAn HTTP client is a library that facilitates in http communication with a given service.\nThe http client should be published in any language needed, by the maintainers of the service it communicates with.\n\n&gt; IMO: An HTTP client can and should also be used by the service owner in integration tests\n\nModern clients care about the following:\n\n* In what environments (locations) does your service exist?\n* What are the endpoints / HTTP paths for these environments?\n* What RESTful APIs exist, and what input do they accept?\n* What do the API responses look like?\n* What is the expected latency for a given API?\n* Should I perform any client-side timeouts or rate limiting?\n* When should I perform a retry for any given API?\n* How do I authenticate myself with your service?\n* How do I serialize / deserialize these json strings?\n* What input limits or formats are required?\n* What form of trace ID do you accept?\n* What are your SLAs for a given API?\n\n### Why you shouldn&#39;t create a HTTP client manually\n\nHere is a pro/cons list to going with the `Manual` approach\n\n| PROS                                        | CONS                                                       |\n| ----                                        | ----                                                       |\n| You have fine-grained control over the code | You must update the code for each API change               |\n|                                             | You must implement libraries for each language you support |\n|                                             | You increase the risk of introducing bugs                  |\n\n### Why you should generate an HTTP client with OpenAPI\n\nThere are many tools available for code generation.\nA very popular one for generating HTTP clients is called OpenAPI\n\nFrom the list of what clients care about, here are the questions that OpenAPI clients solve:\n\n* What are the endpoints / HTTP paths for these environments?\n  * The library should understand what system variables exist and should select the correct endpoint based on whether ENV=DEV/STG/PROD\n* What RESTful APIs exist, and what input do they accept?\n* What do the API responses look like?\n  * OpenAPI clients are generated with the API models defined in the specification file.\n  * See the braindump if you don&#39;t know what the `specification` file is.\n* What is the expected latency for a given API?\n  * Ideally, the OpenAPI spec would have the ability to specify this, but it currently does not.\n  * There is an [open ticket for that](https://github.com/OAI/OpenAPI-Specification/issues/541)\n* Should I perform any client-side timeouts or rate limiting?\n* When should I perform a retry for any given API?\n  * A client library should have these settings preconfigured if they are necessary.\n  * Retry logic can be built on a per-response basis by adding a response interceptor (but beware of retry-hell)\n* How do I authenticate myself with your service?\n* What form of trace ID do you accept?\n  * Authentication / Authorization via api-key and oauth are both supported in the OpenAPI specification\n  * Custom headers for trace IDs are also possible\n* How do I serialize / deserialize these json strings?\n* What input limits or formats are required?\n  * The client library should annotate the class models as necessary to serialize / deserialize them appropriately\n  * The library should also add validation logic on each field to handle input validation for you.\n\n### [WIP] How to generate HTTP clients\n\nIdeally, we would have a single repository where your API specification, service and client would live.\n\nHowever, with limitations in our gitlab pipelines we are only able to produce one artifact per repository.\n\nTherefore, we must split this into 3 repositories:\n\n1. A specification repository\n2. A service repository\n3. A client repository\n\nWhen the specification repository is updated, and merged, the build will trigger the pipelines for the client and the service.\n\nGitlab&#39;s [multi-project pipelines](https://docs.gitlab.com/ee/ci/multi_project_pipelines.html) can be used to accomplish this.</code></pre></div>","frontmatter":{"title":"How to build a modern http client","date":"25 May, 2020","tags":["Http","Microservice","REST","OpenApi"]}}},"pageContext":{"slug":"/content/httpclient/"}}}